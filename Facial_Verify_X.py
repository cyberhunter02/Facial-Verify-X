import streamlit as st
import face_recognition
import numpy as np
import cv2
from datetime import datetime
import io
from fpdf import FPDF
import os

# --- Page and Theme Configuration ---
st.set_page_config(
    page_title="Facial Verify X",
    page_icon="🤖",
    layout="wide",
    initial_sidebar_state="collapsed"
)

# Initialize session state for theme
if 'theme' not in st.session_state:
    st.session_state.theme = 'dark' # Default to dark theme

# --- Custom CSS for a Professional, Next-Level Look ---
st.markdown("""
<style>
    /* Import a clean font */
    @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;700&family=Orbitron:wght@400;700&display=swap');

    /* General Body Styling */
    html, body, .main {
        font-family: 'Roboto', sans-serif;
    }
    
    /* Main container styling */
    .block-container {
        padding-top: 2rem;
        padding-right: 3rem;
        padding-left: 3rem;
        padding-bottom: 2rem;
    }

    /* --- Theme Definitions --- */
    /* Light Theme */
    .light-theme {
        background-color: #FFFFFF;
        color: #333333;
    }
    .light-theme .main-header { color: #0052CC; }
    .light-theme .subheader { color: #5E6C7F; }
    .light-theme .st-emotion-cache-1r6slb0, .light-theme .st-emotion-cache-1v0mbdj, .light-theme .st-emotion-cache-1kyxreq {
        background-color: #F0F2F6; /* Tab background */
    }
    .light-theme .result-box { background-color: #F8F9FA; border: 1px solid #DEE2E6; }
    .light-theme .info-text { color: #495057; }

    /* Dark Theme */
    .dark-theme {
        background-color: #0E1117;
        color: #FAFAFA;
    }
    .dark-theme .main-header { color: #58A6FF; }
    .dark-theme .subheader { color: #8B949E; }
    .dark-theme .st-emotion-cache-1r6slb0, .dark-theme .st-emotion-cache-1v0mbdj, .dark-theme .st-emotion-cache-1kyxreq {
        background-color: #161B22; /* Tab background */
    }
    .dark-theme .result-box { background-color: #1C2128; border: 1px solid #30363D; }
    .dark-theme .info-text { color: #C9D1D9; }
    .dark-theme .st-emotion-cache-10trblm { border-color: #30363D; } /* File uploader border */

    /* --- Component Styling (works for both themes) --- */
    /* Headers and Text */
    .main-header {
        font-family: 'Orbitron', sans-serif;
        font-size: 3rem;
        font-weight: 700;
        text-align: center;
        animation: fadeIn 1.5s ease-in-out;
        text-shadow: 0 0 5px rgba(88, 166, 255, 0.5);
    }
    .subheader {
        font-size: 1.2rem;
        font-weight: 300;
        text-align: center;
        margin-bottom: 2rem;
        animation: fadeIn 1.8s ease-in-out;
    }
    .description-text {
        text-align: center;
        font-size: 1.1rem;
        color: #8B949E;
        max-width: 800px;
        margin: auto;
        margin-bottom: 2rem;
        animation: fadeIn 2s ease-in-out;
    }
    .result-header {
        font-size: 1.5rem;
        font-weight: 700;
        margin-bottom: 1rem;
    }
    .match { color: #28a745; font-weight: bold; }
    .no-match { color: #dc3545; font-weight: bold; }

    /* File Uploader */
    .stFileUploader {
        border-radius: 10px;
        padding: 10px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        transition: box-shadow 0.3s ease;
    }
    .dark-theme .stFileUploader {
         box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    /* Result containers */
    .result-box {
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }
    .dark-theme .result-box {
         box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    /* Animations */
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes popIn {
        0% { transform: scale(0.9); opacity: 0; }
        100% { transform: scale(1); opacity: 1; }
    }
    .pop-in {
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }
    .info-text-container {
        text-align: center;
    }

</style>
""", unsafe_allow_html=True)

# --- PDF Report Generation Class ---
class PDF(FPDF):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.letterhead_path = 'letterhead.png'

    def header(self):
        if os.path.exists(self.letterhead_path):
            self.image(self.letterhead_path, x=0, y=0, w=210)
            self.set_y(40)
        else:
            self.set_y(10)
        
        self.set_font('Helvetica', 'B', 20)
        self.set_text_color(0, 82, 204)
        self.cell(0, 10, 'Facial Verify X - Official Forensic Report', ln=True, align='C')
        self.set_font('Helvetica', '', 12)
        self.set_text_color(128, 128, 128)
        self.cell(0, 8, 'Generated by Cyber Hunter Warrior', ln=True, align='C')
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Helvetica', 'I', 8)
        self.set_text_color(128, 128, 128)
        self.cell(0, 5, 'This report is generated by an automated AI system. Confidence scores are for reference only and should be verified by a human expert.', 0, 0, 'C')
        self.ln(4)
        self.cell(0, 5, f'Page {self.page_no()}', 0, 0, 'C')

def create_pdf_report(report_data, cropped_faces_data):
    pdf = PDF()
    pdf.add_page()
    
    # --- Summary Section ---
    pdf.set_font("Helvetica", 'B', 16)
    pdf.set_fill_color(240, 242, 246)
    pdf.cell(0, 12, "Analysis Summary", ln=1, align='L', fill=True)
    pdf.ln(5)

    pdf.set_font("Helvetica", '', 12)
    pdf.set_text_color(0, 0, 0)
    for key, value in report_data.items():
        pdf.cell(50, 8, f"{key}:", border=0)
        pdf.cell(0, 8, str(value), ln=1, border=0)
    pdf.ln(10)

    # --- Detailed Analysis Section ---
    if not cropped_faces_data:
        pdf.set_font("Helvetica", 'I', 12)
        pdf.cell(0, 10, "No valid face pairs were found for detailed analysis.", ln=1)
    else:
        pdf.set_font("Helvetica", 'B', 16)
        pdf.set_fill_color(240, 242, 246)
        pdf.cell(0, 12, f"Detailed Comparison of {len(cropped_faces_data)} Face Pair(s)", ln=1, align='L', fill=True)
        pdf.ln(5)
        
        for i, (face1_bytes, face2_bytes, confidence, distance, status) in enumerate(cropped_faces_data):
            if pdf.get_y() > 190:
                pdf.add_page()

            pdf.set_font("Helvetica", 'B', 14)
            status_color = (40, 167, 69) if status == "Matched" else (220, 53, 69)
            pdf.set_text_color(*status_color)
            pdf.cell(0, 10, f"Face Pair {i+1}: {status}", ln=1)
            pdf.set_text_color(0, 0, 0)
            
            temp_img1_path = f"temp_face1_{i}.png"
            temp_img2_path = f"temp_face2_{i}.png"
            with open(temp_img1_path, "wb") as f: f.write(face1_bytes.getvalue())
            with open(temp_img2_path, "wb") as f: f.write(face2_bytes.getvalue())
            
            img_y_pos = pdf.get_y()
            pdf.image(temp_img1_path, x=20, y=img_y_pos, w=60)
            pdf.image(temp_img2_path, x=130, y=img_y_pos, w=60)
            pdf.ln(65)
            
            pdf.set_font("Helvetica", 'B', 12)
            pdf.cell(95, 8, "Confidence Score:", align='R')
            pdf.set_font("Helvetica", '', 12)
            pdf.cell(0, 8, f" {confidence}%", ln=1)

            pdf.set_font("Helvetica", 'B', 12)
            pdf.cell(95, 8, "Face Distance (Lower is better):", align='R')
            pdf.set_font("Helvetica", '', 12)
            pdf.cell(0, 8, f" {distance:.4f}", ln=1)
            pdf.ln(10)
            
            os.remove(temp_img1_path)
            os.remove(temp_img2_path)
            
    return pdf.output(dest='S').encode('latin-1')

def create_text_report(report_data, face_analysis_data):
    report_str = "--- Facial Verify X - Official Forensic Report ---\n"
    report_str += "Generated by Cyber Hunter Warrior\n\n"
    report_str += "--- Analysis Summary ---\n"
    for key, value in report_data.items():
        report_str += f"{key}: {value}\n"
    report_str += "\n--- Detailed Comparison ---\n"
    if not face_analysis_data:
        report_str += "No valid face pairs were found for detailed analysis.\n"
    else:
        for i, (_, _, confidence, distance, status) in enumerate(face_analysis_data):
            report_str += f"\nFace Pair {i+1}:\n"
            report_str += f"  - Status: {status}\n"
            report_str += f"  - Match Confidence: {confidence}%\n"
            report_str += f"  - Face Distance Score: {distance:.4f}\n"
    report_str += "\n--- End of Report ---\n"
    return report_str

# --- Helper Functions ---
def load_image(file):
    if file:
        bytes_data = file.read()
        nparr = np.frombuffer(bytes_data, np.uint8)
        return cv2.imdecode(nparr, cv2.IMREAD_COLOR)
    return None

def crop_face(image, face_location):
    top, right, bottom, left = face_location
    margin = 30
    top = max(0, top - margin)
    left = max(0, left - margin)
    bottom = min(image.shape[0], bottom + margin)
    right = min(image.shape[1], right + margin)
    
    cropped_face = image[top:bottom, left:right]
    is_success, buffer = cv2.imencode(".png", cropped_face)
    if is_success:
        return cropped_face, io.BytesIO(buffer)
    return None, None

# --- Main Application UI ---
st.markdown(f'<div class="{st.session_state.theme}-theme">', unsafe_allow_html=True)

# --- Header and Description ---
st.markdown("<h1 class='main-header pop-in'>Facial Verify X</h1>", unsafe_allow_html=True)
st.markdown("<h2 class='subheader pop-in'>Advanced Face Comparison System by Cyber Hunter Warrior</h2>", unsafe_allow_html=True)

with st.expander("About This Tool & Settings", expanded=False):
    st.markdown("""
    **Facial Verify X** is a cutting-edge face comparison tool proudly developed by **Cyber Hunter Warrior (CHW)**, a pioneering organization in cybersecurity awareness, education, and digital safety innovations.
    
    This advanced tool is built for law enforcement, digital investigators, forensic analysts, and corporate security teams who need precise and reliable facial comparison with high accuracy and reporting capabilities.
    
    ### 💡 Key Features:
    - **AI-Powered Face Matching:** Uses `face_recognition` and machine learning for highly accurate face comparison.
    - **Confidence Scoring:** Calculates similarity confidence percentage and the underlying face encoding distance.
    - **Automatic Report Generation:** Creates professional PDF and simple TXT reports of the analysis.
    - **Secure & Offline:** Runs completely locally in your browser. Your images are never uploaded to our servers.
    """)
    st.markdown("---")
    st.markdown("### Theme Settings")
    theme_button_label = f"Toggle to {'Light' if st.session_state.theme == 'dark' else 'Dark'} Mode"
    if st.button(theme_button_label):
        st.session_state.theme = 'light' if st.session_state.theme == 'dark' else 'dark'
        st.rerun()

st.markdown("""
<div style='text-align: center;'>
    <div class='info-text-container pop-in'>
        <p class='description-text'>
            Upload two images to perform a multi-face forensic analysis. Our AI engine will meticulously scan for every face and provide a detailed similarity report for all potential matches.
        </p>
    </div>
    <div style='margin: 0 auto; width: 50%;'>---</div>
</div>
""", unsafe_allow_html=True)

# --- Forensic Settings Sidebar ---
with st.sidebar:
    st.header("Forensic Settings")
    st.markdown("Adjust the threshold for face matching accuracy.")
    match_threshold = st.slider(
        "Forensic Match Threshold",
        min_value=0.1,
        max_value=1.0,
        value=0.5,
        step=0.05,
        help="A lower value means a stricter match (higher accuracy, fewer false positives)."
    )

# --- File Uploaders ---
col1, col2 = st.columns(2)
with col1:
    img1_file = st.file_uploader("Upload First Image", type=["jpg", "jpeg", "png"], key="img1")
with col2:
    img2_file = st.file_uploader("Upload Second Image", type=["jpg", "jpeg", "png"], key="img2")

# --- Main Logic and Analysis Display ---
if img1_file and img2_file:
    image1 = load_image(img1_file)
    image2 = load_image(img2_file)

    display_col1, display_col2 = st.columns(2)
    with display_col1:
        st.image(image1, caption="Image 1", use_container_width=True, channels="BGR")
    with display_col2:
        st.image(image2, caption="Image 2", use_container_width=True, channels="BGR")
    
    st.markdown("---")
    
    with st.spinner("Executing AI Forensic Analysis... Please wait."):
        try:
            face_locations_1 = face_recognition.face_locations(image1)
            face_encodings_1 = face_recognition.face_encodings(image1, face_locations_1)
            
            face_locations_2 = face_recognition.face_locations(image2)
            face_encodings_2 = face_recognition.face_encodings(image2, face_locations_2)

            if not face_encodings_1 or not face_encodings_2:
                st.error("❌ Could not perform analysis. A face must be detected in BOTH images.")
            else:
                results_for_report = []
                
                for i, enc1 in enumerate(face_encodings_1):
                    distances = face_recognition.face_distance(face_encodings_2, enc1)
                    
                    if len(distances) > 0:
                        best_match_index = np.argmin(distances)
                        best_distance = distances[best_match_index]
                        
                        confidence = round(max(0, (1 - best_distance)) * 100, 2)

                        is_match = best_distance < match_threshold
                        status = "Matched" if is_match else "Unmatched"
                        
                        _, buffer1 = crop_face(image1, face_locations_1[i])
                        _, buffer2 = crop_face(image2, face_locations_2[best_match_index])
                        
                        if buffer1 and buffer2:
                            results_for_report.append((buffer1, buffer2, confidence, best_distance, status))

                st.success(f"✅ Analysis Complete. Found {len(face_encodings_1)} face(s) in Image 1 and {len(face_encodings_2)} face(s) in Image 2.")

                if results_for_report:
                    tab_titles = [f"Face Pair {i+1}" for i in range(len(results_for_report))]
                    tabs = st.tabs(["Summary"] + tab_titles)

                    with tabs[0]:
                        st.markdown("<h3 class='result-header pop-in'>Analysis Summary</h3>", unsafe_allow_html=True)
                        total_matches = sum(1 for *_, status in results_for_report if status == "Matched")
                        
                        s_col1, s_col2, s_col3 = st.columns(3)
                        s_col1.metric("Faces in Image 1", len(face_encodings_1))
                        s_col2.metric("Faces in Image 2", len(face_encodings_2))
                        s_col3.metric("Confirmed Matches", total_matches)

                    for i, tab in enumerate(tabs[1:]):
                        with tab:
                            buffer1, buffer2, confidence, distance, status = results_for_report[i]
                            
                            status_class = "match" if status == "Matched" else "no-match"
                            st.markdown(f"<h3>Status: <span class='{status_class}'>{status}</span></h3>", unsafe_allow_html=True)

                            res_col1, res_col2 = st.columns(2)
                            with res_col1:
                                st.image(buffer1.getvalue(), caption=f"Face {i+1} from Image 1", use_container_width=True)
                            with res_col2:
                                st.image(buffer2.getvalue(), caption="Best Match from Image 2", use_container_width=True)
                            
                            st.markdown("---")
                            st.markdown("<h4>Quantitative Metrics</h4>", unsafe_allow_html=True)
                            
                            m_col1, m_col2 = st.columns(2)
                            with m_col1:
                                st.metric("Match Confidence", f"{confidence}%")
                                st.progress(confidence / 100)
                            with m_col2:
                                st.metric("Face Distance Score", f"{distance:.4f}")
                                st.caption("(Lower is a better match)")
                    
                    st.markdown("---")
                    st.subheader("Download Official Reports")
                    
                    report_metadata = {
                        "Date & Time": datetime.now().strftime('%Y-%m-%d %H:%M:%S IST'),
                        "Source Image 1": img1_file.name,
                        "Source Image 2": img2_file.name,
                        "Total Faces in Image 1": len(face_encodings_1),
                        "Total Faces in Image 2": len(face_encodings_2),
                        "Total Matches Found": sum(1 for *_, status in results_for_report if status == "Matched"),
                    }

                    pdf_output = create_pdf_report(report_metadata, results_for_report)
                    txt_output = create_text_report(report_metadata, results_for_report)
                    
                    btn_col1, btn_col2 = st.columns(2)
                    with btn_col1:
                        st.download_button(
                            label="⬇️ Download PDF Report",
                            data=pdf_output,
                            file_name=f"facial_verify_x_report_{datetime.now().strftime('%Y%m%d')}.pdf",
                            mime="application/pdf",
                            use_container_width=True
                        )
                    with btn_col2:
                        st.download_button(
                            label="📄 Download Text Report (.txt)",
                            data=txt_output,
                            file_name=f"facial_verify_x_summary_{datetime.now().strftime('%Y%m%d')}.txt",
                            mime="text/plain",
                            use_container_width=True
                        )

        except Exception as e:
            st.error(f"⚠️ An unexpected error occurred during analysis: {str(e)}")
            st.error("Please try using different images or ensure they are in a standard format (JPG, PNG).")

# --- End of theme container ---
st.markdown('</div>', unsafe_allow_html=True)
